# -*- coding: utf-8 -*-
"""
/***************************************************************************
 TurboVolume
                                 A QGIS plugin
 This plugin calculate volume from raster
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-03-07
        git sha              : $Format:%H$
        copyright            : (C) 2020 by KNGK_GEOINFORMATYKA
        email                : kngk.ggiis@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.core import QgsMapLayerProxyModel, QgsRasterLayer, QgsProject
from qgis.PyQt.QtWidgets import QFileDialog
from qgis.utils import iface

from datetime import datetime
import math
import processing


from osgeo import gdal
import numpy as np

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'Turbo_volume_dialog_base.ui'))


class TurboVolumeDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(TurboVolumeDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # definiowanie akcji wykonywanych po kliknieciu przyciskow lub zmianie watosci
        self.pbPath.clicked.connect(self.select_output_file)
        self.button_box.accepted.connect(self.elevation)
        self.button_box.accepted.connect(self.volume)
        self.button_box.accepted.connect(self.calculateLevel)
        self.pbMin.clicked.connect(self.elevation)
        self.pbMin.clicked.connect(self.refMin)
        self.pbMax.clicked.connect(self.elevation)
        self.pbMax.clicked.connect(self.refMax)
        self.pbDefault.clicked.connect(self.defaultOptions)
        self.gbReport.toggled.connect(self.reportCreatingOptions)
        # nowy checkBox dla granicy
        #self.cmbBorder.toggled.connect(self.elevation)
        #self.gbAreaLimit.stateChanged.connect(self.delete_work)
        
        self.sbDecSpacesH.valueChanged.connect(self.HDecimalsChange)

        self.layers = self.cmbSelectLayer.currentLayer()
        self.cmbSelectLayer.setFilters(QgsMapLayerProxyModel.RasterLayer)

        # nowy comboBox dla granicy obszaru
        self.granica = self.cmbBorder.currentLayer()
        self.cmbBorder.setFilters(QgsMapLayerProxyModel.VectorLayer)


        self.leReport.clear()
        self.dsbReference.setValue(0)

    # wybor pliku wyjsciowego
    def select_output_file(self):
        txfilename, _filter = QFileDialog.getSaveFileName(
            self, "select output text file", "", "*.txt")
        self.leReport.setText(txfilename)

    # usuwanie warstw roboczych (przy wycinaniu tworzą się dwa pliki
    # jest to wynikiem specyfikacji formatu tiff)
    def delete_work(self):
        if self.gbAreaLimit.isChecked():
            resztki = self.tempFile + ".aux.xml"
            del self.layer
            os.remove(self.tempFile)
            os.remove(resztki)

    # odczyt danych z rastra
    def elevation(self):
        self.layer = self.cmbSelectLayer.currentLayer()
        # wycinanie konkretnego obszaru za pomocą warstwy z poligonem
        if self.gbAreaLimit.isChecked():
            # tworzenie warstwy roboczej za pomocą warstwy wejściowej"
            filename = self.layer.dataProvider().dataSourceUri()
            #self.tempFile = filename[:-4] + "robb.tif"   #tu bedzię trzeba porpawić zamiast [:-4] to na pierwsza częsć split kropki
            extLen=len((filename.split('.'))[-1])+1
            border = self.cmbBorder.currentLayer()
            self.tempFile = filename[:-extLen] +"_"+ border.name() +"_limit.tif"
            processing.run('gdal:cliprasterbymasklayer', {'INPUT': self.layer,
                                                          'MASK': border,
                                                          'ALPHA_BAND': False,
                                                          'CROP_TO_CUTLINE': True,
                                                          'KEEP_RESOLUTION': False,
                                                          'OPTIONS': "",
                                                          'DATA_TYPE': 0,
                                                          'OUTPUT': self.tempFile})
            self.layer = QgsRasterLayer(self.tempFile, self.layer.name()+"_"+ border.name() +"_limit")
        else:  # niestety konieczne jest podanie dowolnej wartości ponieważ inaczej niż przez return nie dałem rady wydobyć ścieżki
            self.tempFile = "brak"
        
        
        raster_path = self.layer.source()
        ds = gdal.Open(raster_path)
        band = ds.GetRasterBand(1)
        r = band.ReadAsArray()
        r[r == band.GetNoDataValue()] = np.nan
        self.val=r
        #print (self.val)
        transform = ds.GetGeoTransform()
        pixel_x = abs(transform[1])
        pixel_y = abs(transform[5])
        self.pixel_area = pixel_x * pixel_y
        
        self.hdecimals = self.sbDecSpacesH.value()
        ds = None

        return self.val, self.hdecimals, self.tempFile, self.pixel_area



    # obliczenie objetosci na podstawie: wysokosci plaszczyzny odniesienia, powierzchni piksela, wartosci pikseli
    def volume(self):

        # startTime = datetime.now()
        # print('START',startTime)
        raster_path = self.layer.source()
        ds = gdal.Open(raster_path)
        band = ds.GetRasterBand(1)
        r = band.ReadAsArray()
        r[r == band.GetNoDataValue()] = np.nan
        #print (r[r>0])
        transform = ds.GetGeoTransform()
        pixel_x = abs(transform[1])
        pixel_y = abs(transform[5])
        pixel_area = pixel_x * pixel_y
        #print(['x',pixel_x,'y',pixel_y,'area',pixel_area])
        self.refer = self.dsbReference.value()
        self.fill = np.nansum(pixel_area * (r[r < self.refer] - self.refer))
        self.cut = np.nansum(pixel_area * (r[r > self.refer] - self.refer))
        #print(self.refer, self.fill, self.cut)
        ds = None

        #print('STOP',datetime.now() - startTime)

        return self.cut, self.fill, self.refer




    # odszukanie wysokosci minimalnej na danym rastrze i wpisanie do okna z wysokoscia plaszczyzny odniesienia
    def refMin(self):
        self.dsbReference.setValue(np.nanmin(self.val))
        if self.layer!=self.cmbSelectLayer.currentLayer():
            self.delete_work()

    # odszukanie wysokosci maksymalnej na danym rastrze i wpisanie do okna z wysokoscia plaszczyzny odniesienia
    def refMax(self):
        self.dsbReference.setValue(np.nanmax(self.val))
        if self.layer!=self.cmbSelectLayer.currentLayer():
            self.delete_work()

    # utworzenie raportu txt
    def createReport(self):
        time = datetime.now()

        report = ("time = " + ((str(time))[:-7]) + "\n\n" +
                  "layer = " + str(self.layer.name()) + "\n" +
                  "min height = " + str(round(np.nanmin(self.val), self.hdecimals)) + "\n" +
                  "max height = " + str(round(np.nanmax(self.val), self.hdecimals)) + "\n\n" +
                  "Reference plane height = " + str(self.refer) + "\n" +
                  "cut = " + str(round(self.cut, self.sbDecSpacesV.value())) + "\n" +
                  "fill = " + str(round(self.fill, self.sbDecSpacesV.value())) + "\n\n" +
                  "cut - fill = "+str(self.cut+self.fill) + "\n\n" +
                  self.balanceRep)

        # tworzenie nowego raportu lub dopisywanie do istniejącego (tylko jeśli jest zaznaczona opcja tworzenia raportu)
        if self.gbReport.isChecked():
            if self.rbCreateNew.isChecked():
                outputReport = open(self.leReport.text(), "w")
                outputReport.writelines(report)
                outputReport.close()
            else:
                outputReport = open(self.leReport.text(), "a")
                outputReport.writelines(report)
                outputReport.close()

    # wlaczanie i wylacznie dostepnosci wprowadzania sciezki raportu oraz wyboru rodzaju nowy/dopisz, w zaleznosci czy opcja tworzenia raportu jest zaznaczona
    def reportCreatingOptions(self):
        if self.gbReport.isChecked():
            self.leReport.setEnabled(1)
            self.gbReport.setEnabled(1)
            self.rbCreateNew.setEnabled(1)
            self.rbAdd.setEnabled(1)
        else:
            self.leReport.setEnabled(0)
            #self.gbReport.setEnabled(0)
            self.rbCreateNew.setEnabled(0)
            self.rbAdd.setEnabled(0)

    # definiowanie ustawien domyslnych
    def defaultOptions(self):
        self.gbReport.setChecked(1)
        self.rbCreateNew.setChecked(1)
        self.sbDecSpacesH.setValue(3)
        self.sbDecSpacesV.setValue(3)

    # zmiana ilosci miejsc po przecinku dla wprowadzania wysokosci odniesienia
    def HDecimalsChange(self):
        hdecimals = self.sbDecSpacesH.value()
        self.dsbReference.setDecimals(hdecimals)
    # obliczanie wysokości płaszczyzny dla której różnica między wykopem a nasypem jest równa zadanej objętości (domyślnie 0 - objętość nasypu = objętość wykopu)   
    def calculateLevel(self):
        if self.gbCalcPlane.isChecked():
            self.zeroSumLevel = np.nanmean(self.val*self.pixel_area)-(self.sbSetVolumeSum.value()/(np.count_nonzero(~np.isnan(self.val))))
            
            self.zeroSumLevel=str(round(self.zeroSumLevel, self.hdecimals))
            balanceVal=str(self.sbSetVolumeSum.value())
            self.balanceRep=(
            "Given balance volume = " + balanceVal + "\n"+
            "Balanced referencded plane height = "+ self.zeroSumLevel + "\n\n"+
            "# # # # # # # # # # # # # # # # # # # # # # #\n\n")
            
        else:
            self.balanceRep=('')
        return self.balanceRep
